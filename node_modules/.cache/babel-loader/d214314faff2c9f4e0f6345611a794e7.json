{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar MagicSliderDots = function (_Component) {\n  inherits(MagicSliderDots, _Component);\n\n  function MagicSliderDots(props) {\n    classCallCheck(this, MagicSliderDots); // init\n\n    var _this = possibleConstructorReturn(this, (MagicSliderDots.__proto__ || Object.getPrototypeOf(MagicSliderDots)).call(this, props));\n\n    _this.previousActiveIndex = 0;\n    _this.hasAnimated = false;\n    _this.minIndex = 0;\n    _this.maxIndex = 0;\n    _this.breakPointActiveIndex = 0;\n    _this.addActiveClassToLastDot = false;\n    return _this;\n  } //handle react-slick breakpoints\n\n\n  createClass(MagicSliderDots, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var prevDots = prevProps.dots;\n      var _props = this.props,\n          currentDots = _props.dots,\n          activeDotClassName = _props.activeDotClassName,\n          numDotsToShow = _props.numDotsToShow; //moving from more dots to less dots\n\n      if (prevDots && currentDots && prevDots.length > currentDots.length) {\n        //edge case - last dot was active\n        if (prevDots[prevDots.length - 1].props.className === activeDotClassName) {\n          this.breakPointActiveIndex = currentDots.length - 1;\n          this.previousActiveIndex = this.breakPointActiveIndex - 1;\n          this.addActiveClassToLastDot = true;\n        } //edge case - last active index is at end of current dots or exceeds current dot length\n\n\n        var lastActiveDot = prevDots.find(function (dot) {\n          return dot.props.className === activeDotClassName;\n        });\n        var lastActiveIndex = parseInt(lastActiveDot.key);\n\n        if (lastActiveIndex > currentDots.length - 1) {\n          this.breakPointActiveIndex = currentDots.length - 1;\n          this.previousActiveIndex = this.breakPointActiveIndex - 1;\n          this.addActiveClassToLastDot = true;\n        } //adjust minIndex and maxIndex if necessary\n\n\n        if (this.minIndex < 0) {\n          this.minIndex = 0;\n          this.maxIndex = numDotsToShow - 1;\n        }\n\n        if (this.maxIndex > currentDots.length - 1) {\n          this.maxIndex = currentDots.length - 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        }\n\n        this.forceUpdate();\n      } else if (prevDots && currentDots && prevDots.length < currentDots.length) {\n        //edge case - adjust minIndex and maxIndex if active dot will be out of the View determined by min/max index\n        var currentActiveDot = currentDots.find(function (dot) {\n          return dot.props.className === activeDotClassName;\n        });\n        var currentActiveIndex = parseInt(currentActiveDot.key);\n\n        if (currentActiveIndex >= this.maxIndex) {\n          this.maxIndex = currentActiveIndex + 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        } //adjust minIndex and maxIndex if necessary\n\n\n        if (this.maxIndex > currentDots.length - 1) {\n          this.maxIndex = currentDots.length - 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        }\n\n        this.forceUpdate();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props2 = this.props,\n          dots = _props2.dots,\n          numDotsToShow = _props2.numDotsToShow,\n          dotWidth = _props2.dotWidth,\n          dotContainerClassName = _props2.dotContainerClassName,\n          activeDotClassName = _props2.activeDotClassName,\n          prevNextDotClassName = _props2.prevNextDotClassName;\n      var active = dots.find(function (dot) {\n        return dot.props.className === activeDotClassName;\n      });\n      var adjustedDots = [].concat(toConsumableArray(dots)); //if no current activeIndex, then due to react-slick breakpoint - use generated breakPointActiveIndex\n\n      var activeIndex = active ? parseInt(active.key) : this.breakPointActiveIndex; //consider '>=' as moving forward to support react-slick breakpoint use case\n\n      var isMovingForward = activeIndex >= this.previousActiveIndex; // need to subtract 2 from numDotsToShow since array index are zero-based\n\n      if (activeIndex > numDotsToShow - 2 && adjustedDots.length > numDotsToShow || this.hasAnimated) {\n        if (isMovingForward) {\n          if (activeIndex === this.maxIndex && activeIndex !== dots.length - 1) {\n            // list will move left\n            this.minIndex = activeIndex - (numDotsToShow - 2);\n            this.maxIndex = activeIndex + 1;\n          } else {\n            // special case - handle if initialSlide from react-slick has a value greater than 0\n            if (this.minIndex === 0 && this.maxIndex === 0) {\n              if (activeIndex === dots.length - 1) {\n                this.maxIndex = activeIndex;\n                this.minIndex = this.maxIndex - (numDotsToShow - 1);\n              } else {\n                this.minIndex = activeIndex - 1 < 0 ? 0 : activeIndex - 1;\n                this.maxIndex = this.minIndex + (numDotsToShow - 1) > dots.length - 1 ? dots.length - 1 : this.minIndex + (numDotsToShow - 1);\n              }\n            } else {\n              if (activeIndex === dots.length - 1) {\n                // moving carousel backward from 0 to max index\n                this.maxIndex = dots.length - 1;\n                this.minIndex = dots.length - numDotsToShow;\n              }\n            }\n          }\n        } else {\n          // movingBackwards\n          if (activeIndex === this.minIndex && activeIndex !== 0) {\n            // list will move right\n            this.minIndex = activeIndex - 1;\n            this.maxIndex = this.minIndex + (numDotsToShow - 1);\n          } else {\n            if (activeIndex === 0) {\n              // moving carousel forward from max index to 0\n              this.maxIndex = numDotsToShow - 1;\n              this.minIndex = 0;\n            }\n          }\n        }\n\n        this.hasAnimated = true;\n        var firstViewableDotIndex = this.minIndex;\n        var firstViewableDot = adjustedDots[firstViewableDotIndex];\n        var lastViewableDotIndex = this.maxIndex;\n        var lastViewableDot = adjustedDots[lastViewableDotIndex]; //outside of bounds check - can be caused when using react-slick breakpoints\n        //return null and dots will correctly re-render once componentDidUpdate lifecycle recalculates indexes\n\n        if (!firstViewableDot || !lastViewableDot) {\n          console.log('rendering null - outside of bounds', firstViewableDot, lastViewableDot);\n          return null;\n        }\n\n        if (lastViewableDotIndex < adjustedDots.length - 1 && isMovingForward) {\n          // moving foward - but not on the last dot\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        } else if (lastViewableDotIndex === adjustedDots.length - 1) {\n          // moving foward or backward - last dot visible - should appear not small\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [this.addActiveClassToLastDot || activeIndex === lastViewableDotIndex ? React.cloneElement(lastViewableDot, {\n            className: this.props.activeDotClassName\n          }) : lastViewableDot]);\n        } else if (activeIndex > 1 && !isMovingForward) {\n          // moving backwards the left\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        } else {\n          this.hasAnimated = false; // moving backwards on first dot - should appear not small\n          // eq: (activeIndex === 1 || activeIndex === 0) && !isMovingForward\n\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        }\n      } // no leftOffset in place, just render the dots\n      else {\n        var _lastViewableDotIndex = Math.min(numDotsToShow, dots.length) - 1;\n\n        this.minIndex = 0;\n        this.maxIndex = _lastViewableDotIndex;\n\n        if (_lastViewableDotIndex < adjustedDots.length - 1) {\n          var _lastViewableDot = adjustedDots[_lastViewableDotIndex];\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, _lastViewableDotIndex)), [React.cloneElement(_lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(_lastViewableDotIndex + 1)));\n        }\n      } // track active index\n\n\n      this.previousActiveIndex = activeIndex;\n      this.addActiveClassToLastDot = false; // calculate container width\n\n      var containerWidth = dots.length < numDotsToShow ? dots.length * dotWidth : numDotsToShow * dotWidth;\n      var midIndex = (this.minIndex + this.maxIndex) / 2; // only give leftOffset if number of dots exceeds number of dots to show at one time\n\n      var leftOffset = dots.length < numDotsToShow ? 0 : (dotWidth * numDotsToShow - dotWidth) / 2 - midIndex * dotWidth;\n      return React.createElement('div', {\n        className: dotContainerClassName,\n        style: {\n          position: 'relative',\n          overflow: 'hidden',\n          margin: 'auto',\n          width: containerWidth + 'px'\n        }\n      }, React.createElement('ul', {\n        style: {\n          transform: 'translateX(' + leftOffset + 'px)'\n        }\n      }, ' ', adjustedDots, ' '));\n    }\n  }]);\n  return MagicSliderDots;\n}(Component);\n\nMagicSliderDots.propTypes = {\n  /** array of HTML li elements representing the slider dot.   */\n  dots: PropTypes.array.isRequired,\n\n  /** number of slider dots to show. */\n  numDotsToShow: PropTypes.number.isRequired,\n\n  /** width, in pixels, of a slider dot including any margins/padding. */\n  dotWidth: PropTypes.number.isRequired,\n\n  /** class name of parent div. */\n  dotContainerClassName: PropTypes.string,\n\n  /** class name of active slider dot. */\n  activeDotClassName: PropTypes.string,\n\n  /** class name of left-most (prev) and right-most (next) slider dot. */\n  prevNextDotClassName: PropTypes.string\n};\nMagicSliderDots.defaultProps = {\n  dotContainerClassName: 'magic-dots slick-dots',\n  activeDotClassName: 'slick-active',\n  prevNextDotClassName: 'small'\n};\nexport default MagicSliderDots;","map":{"version":3,"sources":["../src/index.js"],"names":["MagicSliderDots","Component","prevProps","prevDots","currentDots","activeDotClassName","numDotsToShow","lastActiveDot","dot","lastActiveIndex","parseInt","currentActiveDot","currentActiveIndex","dots","dotWidth","dotContainerClassName","prevNextDotClassName","active","adjustedDots","activeIndex","isMovingForward","firstViewableDotIndex","firstViewableDot","lastViewableDotIndex","lastViewableDot","Math","containerWidth","midIndex","leftOffset","transform","PropTypes","string"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './magic-dots.css';\n\nexport default class MagicSliderDots extends Component {\n  constructor(props) {\n    super(props);\n\n    // init\n    this.previousActiveIndex = 0;\n    this.hasAnimated = false;\n    this.minIndex = 0;\n    this.maxIndex = 0;\n    this.breakPointActiveIndex = 0;\n    this.addActiveClassToLastDot = false;\n  }\n\n  //handle react-slick breakpoints\n  componentDidUpdate(prevProps) {\n    const prevDots = prevProps.dots;\n    const { dots: currentDots, activeDotClassName, numDotsToShow } = this.props;\n\n    //moving from more dots to less dots\n    if (prevDots && currentDots && prevDots.length > currentDots.length) {\n      //edge case - last dot was active\n      if (prevDots[prevDots.length - 1].props.className === activeDotClassName) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //edge case - last active index is at end of current dots or exceeds current dot length\n      const lastActiveDot = prevDots.find(dot => dot.props.className === activeDotClassName);\n      let lastActiveIndex = parseInt(lastActiveDot.key);\n\n      if (lastActiveIndex > currentDots.length - 1) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.minIndex < 0) {\n        this.minIndex = 0;\n        this.maxIndex = numDotsToShow - 1;\n      }\n\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    } else if (prevDots && currentDots && prevDots.length < currentDots.length) {\n      //edge case - adjust minIndex and maxIndex if active dot will be out of the View determined by min/max index\n      const currentActiveDot = currentDots.find(dot => dot.props.className === activeDotClassName);\n      let currentActiveIndex = parseInt(currentActiveDot.key);\n\n      if (currentActiveIndex >= this.maxIndex) {\n        this.maxIndex = currentActiveIndex + 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  render() {\n    const {\n      dots,\n      numDotsToShow,\n      dotWidth,\n      dotContainerClassName,\n      activeDotClassName,\n      prevNextDotClassName\n    } = this.props;\n\n    const active = dots.find(dot => dot.props.className === activeDotClassName);\n    let adjustedDots = [...dots];\n    //if no current activeIndex, then due to react-slick breakpoint - use generated breakPointActiveIndex\n    let activeIndex = active ? parseInt(active.key) : this.breakPointActiveIndex;\n    //consider '>=' as moving forward to support react-slick breakpoint use case\n    const isMovingForward = activeIndex >= this.previousActiveIndex;\n\n    // need to subtract 2 from numDotsToShow since array index are zero-based\n    if (\n      (activeIndex > numDotsToShow - 2 && adjustedDots.length > numDotsToShow) ||\n      this.hasAnimated\n    ) {\n      if (isMovingForward) {\n        if (activeIndex === this.maxIndex && activeIndex !== dots.length - 1) {\n          // list will move left\n          this.minIndex = activeIndex - (numDotsToShow - 2);\n          this.maxIndex = activeIndex + 1;\n        } else {\n          // special case - handle if initialSlide from react-slick has a value greater than 0\n          if (this.minIndex === 0 && this.maxIndex === 0) {\n            if (activeIndex === dots.length - 1) {\n              this.maxIndex = activeIndex;\n              this.minIndex = this.maxIndex - (numDotsToShow - 1);\n            } else {\n              this.minIndex = activeIndex - 1 < 0 ? 0 : activeIndex - 1;\n              this.maxIndex =\n                this.minIndex + (numDotsToShow - 1) > dots.length - 1\n                  ? dots.length - 1\n                  : this.minIndex + (numDotsToShow - 1);\n            }\n          } else {\n            if (activeIndex === dots.length - 1) {\n              // moving carousel backward from 0 to max index\n              this.maxIndex = dots.length - 1;\n              this.minIndex = dots.length - numDotsToShow;\n            }\n          }\n        }\n      } else {\n        // movingBackwards\n        if (activeIndex === this.minIndex && activeIndex !== 0) {\n          // list will move right\n          this.minIndex = activeIndex - 1;\n          this.maxIndex = this.minIndex + (numDotsToShow - 1);\n        } else {\n          if (activeIndex === 0) {\n            // moving carousel forward from max index to 0\n            this.maxIndex = numDotsToShow - 1;\n            this.minIndex = 0;\n          }\n        }\n      }\n\n      this.hasAnimated = true;\n      const firstViewableDotIndex = this.minIndex;\n      const firstViewableDot = adjustedDots[firstViewableDotIndex];\n      const lastViewableDotIndex = this.maxIndex;\n      const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n      //outside of bounds check - can be caused when using react-slick breakpoints\n      //return null and dots will correctly re-render once componentDidUpdate lifecycle recalculates indexes\n      if (!firstViewableDot || !lastViewableDot) {\n        console.log('rendering null - outside of bounds', firstViewableDot, lastViewableDot);\n        return null;\n      }\n\n      if (lastViewableDotIndex < adjustedDots.length - 1 && isMovingForward) {\n        // moving foward - but not on the last dot\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else if (lastViewableDotIndex === adjustedDots.length - 1) {\n        // moving foward or backward - last dot visible - should appear not small\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          this.addActiveClassToLastDot || activeIndex === lastViewableDotIndex\n            ? React.cloneElement(lastViewableDot, {\n                className: this.props.activeDotClassName\n              })\n            : lastViewableDot\n        ];\n      } else if (activeIndex > 1 && !isMovingForward) {\n        // moving backwards the left\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else {\n        this.hasAnimated = false;\n        // moving backwards on first dot - should appear not small\n        // eq: (activeIndex === 1 || activeIndex === 0) && !isMovingForward\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n    // no leftOffset in place, just render the dots\n    else {\n      const lastViewableDotIndex = Math.min(numDotsToShow, dots.length) - 1;\n      this.minIndex = 0;\n      this.maxIndex = lastViewableDotIndex;\n\n      if (lastViewableDotIndex < adjustedDots.length - 1) {\n        const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n\n    // track active index\n    this.previousActiveIndex = activeIndex;\n    this.addActiveClassToLastDot = false;\n    // calculate container width\n    const containerWidth =\n      dots.length < numDotsToShow ? dots.length * dotWidth : numDotsToShow * dotWidth;\n\n    const midIndex = (this.minIndex + this.maxIndex) / 2;\n\n    // only give leftOffset if number of dots exceeds number of dots to show at one time\n    const leftOffset =\n      dots.length < numDotsToShow\n        ? 0\n        : (dotWidth * numDotsToShow - dotWidth) / 2 - midIndex * dotWidth;\n\n    return (\n      <div\n        className={dotContainerClassName}\n        style={{\n          position: 'relative',\n          overflow: 'hidden',\n          margin: 'auto',\n          width: containerWidth + 'px'\n        }}\n      >\n        <ul style={{ transform: `translateX(${leftOffset}px)` }}> {adjustedDots} </ul>\n      </div>\n    );\n  }\n}\n\nMagicSliderDots.propTypes = {\n  /** array of HTML li elements representing the slider dot.   */\n  dots: PropTypes.array.isRequired,\n  /** number of slider dots to show. */\n  numDotsToShow: PropTypes.number.isRequired,\n  /** width, in pixels, of a slider dot including any margins/padding. */\n  dotWidth: PropTypes.number.isRequired,\n  /** class name of parent div. */\n  dotContainerClassName: PropTypes.string,\n  /** class name of active slider dot. */\n  activeDotClassName: PropTypes.string,\n  /** class name of left-most (prev) and right-most (next) slider dot. */\n  prevNextDotClassName: PropTypes.string\n};\n\nMagicSliderDots.defaultProps = {\n  dotContainerClassName: 'magic-dots slick-dots',\n  activeDotClassName: 'slick-active',\n  prevNextDotClassName: 'small'\n};\n"]},"metadata":{},"sourceType":"module"}